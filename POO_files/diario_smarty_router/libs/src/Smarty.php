<?php
 namespace Smarty; use FilesystemIterator; use RecursiveDirectoryIterator; use RecursiveIteratorIterator; use Smarty\Cacheresource\File; use Smarty\Extension\Base; use Smarty\Extension\BCPluginsAdapter; use Smarty\Extension\CallbackWrapper; use Smarty\Extension\CoreExtension; use Smarty\Extension\DefaultExtension; use Smarty\Extension\ExtensionInterface; use Smarty\Filter\Output\TrimWhitespace; use Smarty\Runtime\CaptureRuntime; use Smarty\Runtime\DefaultPluginHandlerRuntime; use Smarty\Runtime\ForeachRuntime; use Smarty\Runtime\InheritanceRuntime; use Smarty\Runtime\TplFunctionRuntime; class Smarty extends \Smarty\TemplateBase { const SMARTY_VERSION = '5.5.2'; const CACHING_OFF = 0; const CACHING_LIFETIME_CURRENT = 1; const CACHING_LIFETIME_SAVED = 2; const CLEAR_EXPIRED = -1; const COMPILECHECK_OFF = 0; const COMPILECHECK_ON = 1; const FILTER_POST = 'post'; const FILTER_PRE = 'pre'; const FILTER_OUTPUT = 'output'; const FILTER_VARIABLE = 'variable'; const PLUGIN_FUNCTION = 'function'; const PLUGIN_BLOCK = 'block'; const PLUGIN_COMPILER = 'compiler'; const PLUGIN_MODIFIER = 'modifier'; const PLUGIN_MODIFIERCOMPILER = 'modifiercompiler'; public static $_CHARSET = 'UTF-8'; public static $_DATE_FORMAT = '%b %e, %Y'; public static $_UTF8_MODIFIER = 'u'; public static $_IS_WINDOWS = false; public $auto_literal = true; public $error_unassigned = false; public $_templateDirNormalized = false; public $_joined_template_dir = null; public $_configDirNormalized = false; public $_joined_config_dir = null; public $default_template_handler_func = null; public $default_config_handler_func = null; private $default_plugin_handler_func = null; public $_compileDirNormalized = false; public $_cacheDirNormalized = false; public $force_compile = false; public $use_sub_dirs = false; public $merge_compiled_includes = false; public $force_cache = false; private $left_delimiter = "{"; private $right_delimiter = "}"; public $literals = []; public $security_class = \Smarty\Security::class; public $security_policy = null; public $debugging = false; public $debugging_ctrl = 'NONE'; public $smarty_debug_id = 'SMARTY_DEBUG'; public $debug_tpl = null; public $error_reporting = null; public $config_overwrite = true; public $config_booleanize = true; public $config_read_hidden = false; public $compile_locking = true; public $cache_locking = false; public $locking_timeout = 10; public $default_resource_type = 'file'; private $cacheResource; public $default_config_type = 'file'; public $cache_modified_check = false; public $registered_plugins = []; public $registered_objects = []; public $registered_classes = []; public $registered_resources = []; private $registered_cache_resources = []; public $default_modifiers = []; public $escape_html = false; public $start_time = 0; public $_parserdebug = false; public $_debug = null; protected $template_dir = ['./templates/']; protected $_processedTemplateDir = []; protected $config_dir = ['./configs/']; protected $_processedConfigDir = []; protected $compile_dir = './templates_c/'; protected $cache_dir = './cache/'; private $isMutingUndefinedOrNullWarnings = false; public $_resource_handlers = []; public $_cacheresource_handlers = []; private $extensions = []; private $BCPluginsAdapter; public function __construct() { $this->start_time = microtime(true); \Smarty\Smarty::$_IS_WINDOWS = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN'; if (\Smarty\Smarty::$_CHARSET !== 'UTF-8') { \Smarty\Smarty::$_UTF8_MODIFIER = ''; } $this->BCPluginsAdapter = new BCPluginsAdapter($this); $this->extensions[] = new CoreExtension(); $this->extensions[] = new DefaultExtension(); $this->extensions[] = $this->BCPluginsAdapter; $this->cacheResource = new File(); } public function addExtension(ExtensionInterface $extension) { $this->extensions[] = $extension; } public function getExtensions(): array { return $this->extensions; } public function setExtensions(array $extensions): void { $this->extensions = $extensions; } public function templateExists($resource_name) { $source = Template\Source::load(null, $this, $resource_name); return $source->exists; } public function enableSecurity($security_class = null) { \Smarty\Security::enableSecurity($this, $security_class); return $this; } public function disableSecurity() { $this->security_policy = null; return $this; } public function addTemplateDir($template_dir, $key = null, $isConfig = false) { if ($isConfig) { $processed = &$this->_processedConfigDir; $dir = &$this->config_dir; $this->_configDirNormalized = false; } else { $processed = &$this->_processedTemplateDir; $dir = &$this->template_dir; $this->_templateDirNormalized = false; } if (is_array($template_dir)) { foreach ($template_dir as $k => $v) { if (is_int($k)) { $dir[] = $v; } else { $dir[$k] = $v; unset($processed[$key]); } } } else { if ($key !== null) { $dir[$key] = $template_dir; unset($processed[$key]); } else { $dir[] = $template_dir; } } return $this; } public function getTemplateDir($index = null, $isConfig = false) { if ($isConfig) { $dir = &$this->config_dir; } else { $dir = &$this->template_dir; } if ($isConfig ? !$this->_configDirNormalized : !$this->_templateDirNormalized) { $this->_normalizeTemplateConfig($isConfig); } if ($index !== null) { return isset($dir[$index]) ? $dir[$index] : null; } return $dir; } public function setTemplateDir($template_dir, $isConfig = false) { if ($isConfig) { $this->config_dir = []; $this->_processedConfigDir = []; } else { $this->template_dir = []; $this->_processedTemplateDir = []; } $this->addTemplateDir($template_dir, null, $isConfig); return $this; } public function prependTemplateDir($new_template_dir, $is_config = false) { $current_template_dirs = $is_config ? $this->config_dir : $this->template_dir; array_unshift($current_template_dirs, $new_template_dir); $this->setTemplateDir($current_template_dirs, $is_config); return $this; } public function addConfigDir($config_dir, $key = null) { return $this->addTemplateDir($config_dir, $key, true); } public function getConfigDir($index = null) { return $this->getTemplateDir($index, true); } public function setConfigDir($config_dir) { return $this->setTemplateDir($config_dir, true); } public function registerPlugin($type, $name, $callback, $cacheable = true) { if (isset($this->registered_plugins[$type][$name])) { throw new Exception("Plugin tag '{$name}' already registered"); } elseif (!is_callable($callback) && !class_exists($callback)) { throw new Exception("Plugin '{$name}' not callable"); } else { $this->registered_plugins[$type][$name] = [$callback, (bool)$cacheable]; } return $this; } public function getRegisteredPlugin($type, $name): ?array { if (isset($this->registered_plugins[$type][$name])) { return $this->registered_plugins[$type][$name]; } return null; } public function unregisterPlugin($type, $name) { if (isset($this->registered_plugins[$type][$name])) { unset($this->registered_plugins[$type][$name]); } return $this; } public function addPluginsDir($plugins_dir) { trigger_error('Using Smarty::addPluginsDir() to load plugins is deprecated and will be ' . 'removed in a future release. Use Smarty::addExtension() to add an extension or Smarty::registerPlugin to ' . 'quickly register a plugin using a callback function.', E_USER_DEPRECATED); foreach ((array)$plugins_dir as $v) { $path = $this->_realpath(rtrim($v ?? '', '/\\') . DIRECTORY_SEPARATOR, true); $this->BCPluginsAdapter->loadPluginsFromDir($path); } return $this; } public function getPluginsDir() { trigger_error('Using Smarty::getPluginsDir() is deprecated and will be ' . 'removed in a future release. It will always return an empty array.', E_USER_DEPRECATED); return []; } public function setPluginsDir($plugins_dir) { trigger_error('Using Smarty::getPluginsDir() is deprecated and will be ' . 'removed in a future release. For now, it will remove the DefaultExtension from the extensions list and ' . 'proceed to call Smartyy::addPluginsDir..', E_USER_DEPRECATED); $this->extensions = array_filter( $this->extensions, function ($extension) { return !($extension instanceof DefaultExtension); } ); return $this->addPluginsDir($plugins_dir); } public function registerDefaultPluginHandler($callback) { trigger_error('Using Smarty::registerDefaultPluginHandler() is deprecated and will be ' . 'removed in a future release. Please rewrite your plugin handler as an extension.', E_USER_DEPRECATED); if (is_callable($callback)) { $this->default_plugin_handler_func = $callback; } else { throw new Exception("Default plugin handler '$callback' not callable"); } return $this; } public function getCompileDir() { if (!$this->_compileDirNormalized) { $this->_normalizeDir('compile_dir', $this->compile_dir); $this->_compileDirNormalized = true; } return $this->compile_dir; } public function setCompileDir($compile_dir) { $this->_normalizeDir('compile_dir', $compile_dir); $this->_compileDirNormalized = true; return $this; } public function getCacheDir() { if (!$this->_cacheDirNormalized) { $this->_normalizeDir('cache_dir', $this->cache_dir); $this->_cacheDirNormalized = true; } return $this->cache_dir; } public function setCacheDir($cache_dir) { $this->_normalizeDir('cache_dir', $cache_dir); $this->_cacheDirNormalized = true; return $this; } private $templates = []; public function createTemplate($template_name, $cache_id = null, $compile_id = null, $parent = null): Template { $data = []; if (is_object($cache_id)) { $parent = $cache_id; $cache_id = null; } if (is_array($cache_id)) { $data = $cache_id; $cache_id = null; } return $this->doCreateTemplate($template_name, $cache_id, $compile_id, $parent, null, null, false, $data); } private function generateUniqueTemplateId( $resource_name, $cache_id = null, $compile_id = null, $caching = null ): string { $cache_id = $cache_id ?? $this->cache_id; $compile_id = $compile_id ?? $this->compile_id; $caching = (int)$caching ?? $this->caching; if (strpos($resource_name, ':') === false) { $resource_name = "{$this->default_resource_type}:{$resource_name}"; } $_templateId = $resource_name . '#' . $cache_id . '#' . $compile_id . '#' . $caching; if (strlen($_templateId) > 150) { $_templateId = sha1($_templateId); } return $_templateId; } public function _realpath($path, $realpath = null) { $nds = ['/' => '\\', '\\' => '/']; preg_match( '%^(?<root>(?:[[:alpha:]]:[\\\\/]|/|[\\\\]{2}[[:alpha:]]+|[[:print:]]{2,}:[/]{2}|[\\\\])?)(?<path>(.*))$%u', $path, $parts ); $path = $parts['path']; if ($parts['root'] === '\\') { $parts['root'] = substr(getcwd(), 0, 2) . $parts['root']; } else { if ($realpath !== null && !$parts['root']) { $path = getcwd() . DIRECTORY_SEPARATOR . $path; } } $path = str_replace($nds[DIRECTORY_SEPARATOR], DIRECTORY_SEPARATOR, $path); $parts['root'] = str_replace($nds[DIRECTORY_SEPARATOR], DIRECTORY_SEPARATOR, $parts['root']); do { $path = preg_replace( ['#[\\\\/]{2}#', '#[\\\\/][.][\\\\/]#', '#[\\\\/]([^\\\\/.]+)[\\\\/][.][.][\\\\/]#'], DIRECTORY_SEPARATOR, $path, -1, $count ); } while ($count > 0); return $realpath !== false ? $parts['root'] . $path : str_ireplace(getcwd(), '.', $parts['root'] . $path); } public function setUseSubDirs($use_sub_dirs) { $this->use_sub_dirs = $use_sub_dirs; } public function setErrorReporting($error_reporting) { $this->error_reporting = $error_reporting; } public function setEscapeHtml($escape_html) { $this->escape_html = $escape_html; } public function getAutoLiteral() { return $this->auto_literal; } public function setAutoLiteral($auto_literal = true) { $this->auto_literal = $auto_literal; } public function setForceCompile($force_compile) { $this->force_compile = $force_compile; } public function setMergeCompiledIncludes($merge_compiled_includes) { $this->merge_compiled_includes = $merge_compiled_includes; } public function getLeftDelimiter() { return $this->left_delimiter; } public function setLeftDelimiter($left_delimiter) { $this->left_delimiter = $left_delimiter; } public function getRightDelimiter() { return $this->right_delimiter; } public function setRightDelimiter($right_delimiter) { $this->right_delimiter = $right_delimiter; } public function setDebugging($debugging) { $this->debugging = $debugging; } public function setConfigOverwrite($config_overwrite) { $this->config_overwrite = $config_overwrite; } public function setConfigBooleanize($config_booleanize) { $this->config_booleanize = $config_booleanize; } public function setConfigReadHidden($config_read_hidden) { $this->config_read_hidden = $config_read_hidden; } public function setCompileLocking($compile_locking) { $this->compile_locking = $compile_locking; } public function setDefaultResourceType($default_resource_type) { $this->default_resource_type = $default_resource_type; } public function testInstall(&$errors = null) { \Smarty\TestInstall::testInstall($this, $errors); } public function getSmarty() { return $this; } private function _normalizeDir($dirName, $dir) { $this->{$dirName} = $this->_realpath(rtrim($dir ?? '', "/\\") . DIRECTORY_SEPARATOR, true); } private function _normalizeTemplateConfig($isConfig) { if ($isConfig) { $processed = &$this->_processedConfigDir; $dir = &$this->config_dir; } else { $processed = &$this->_processedTemplateDir; $dir = &$this->template_dir; } if (!is_array($dir)) { $dir = (array)$dir; } foreach ($dir as $k => $v) { if (!isset($processed[$k])) { $dir[$k] = $this->_realpath(rtrim($v ?? '', "/\\") . DIRECTORY_SEPARATOR, true); $processed[$k] = true; } } if ($isConfig) { $this->_configDirNormalized = true; $this->_joined_config_dir = join('#', $this->config_dir); } else { $this->_templateDirNormalized = true; $this->_joined_template_dir = join('#', $this->template_dir); } } public function muteUndefinedOrNullWarnings(): void { $this->isMutingUndefinedOrNullWarnings = true; } public function isMutingUndefinedOrNullWarnings(): bool { return $this->isMutingUndefinedOrNullWarnings; } public function clearCache( $template_name, $cache_id = null, $compile_id = null, $exp_time = null ) { return $this->getCacheResource()->clear($this, $template_name, $cache_id, $compile_id, $exp_time); } public function clearAllCache($exp_time = null) { return $this->getCacheResource()->clearAll($this, $exp_time); } public function clearCompiledTemplate($resource_name = null, $compile_id = null, $exp_time = null) { $_compile_dir = $this->getCompileDir(); if ($_compile_dir === '/') { return 0; } $_compile_id = isset($compile_id) ? preg_replace('![^\w]+!', '_', $compile_id) : null; $_dir_sep = $this->use_sub_dirs ? DIRECTORY_SEPARATOR : '^'; if (isset($resource_name)) { $_save_stat = $this->caching; $this->caching = \Smarty\Smarty::CACHING_OFF; $tpl = $this->doCreateTemplate($resource_name); $this->caching = $_save_stat; if (!$tpl->getSource()->handler->recompiled && $tpl->getSource()->exists) { $_resource_part_1 = basename(str_replace('^', DIRECTORY_SEPARATOR, $tpl->getCompiled()->filepath)); $_resource_part_1_length = strlen($_resource_part_1); } else { return 0; } $_resource_part_2 = str_replace('.php', '.cache.php', $_resource_part_1); $_resource_part_2_length = strlen($_resource_part_2); } $_dir = $_compile_dir; if ($this->use_sub_dirs && isset($_compile_id)) { $_dir .= $_compile_id . $_dir_sep; } if (isset($_compile_id)) { $_compile_id_part = $_compile_dir . $_compile_id . $_dir_sep; $_compile_id_part_length = strlen($_compile_id_part); } $_count = 0; try { $_compileDirs = new RecursiveDirectoryIterator($_dir); } catch (\UnexpectedValueException $e) { return 0; } $_compile = new RecursiveIteratorIterator($_compileDirs, RecursiveIteratorIterator::CHILD_FIRST); foreach ($_compile as $_file) { if (substr(basename($_file->getPathname()), 0, 1) === '.') { continue; } $_filepath = (string)$_file; if ($_file->isDir()) { if (!$_compile->isDot()) { @rmdir($_file->getPathname()); } } else { if (substr($_filepath, -4) !== '.php') { continue; } $unlink = false; if ((!isset($_compile_id) || (isset($_filepath[$_compile_id_part_length]) && $a = !strncmp($_filepath, $_compile_id_part, $_compile_id_part_length))) && (!isset($resource_name) || (isset($_filepath[$_resource_part_1_length]) && substr_compare( $_filepath, $_resource_part_1, -$_resource_part_1_length, $_resource_part_1_length ) === 0) || (isset($_filepath[$_resource_part_2_length]) && substr_compare( $_filepath, $_resource_part_2, -$_resource_part_2_length, $_resource_part_2_length ) === 0)) ) { if (isset($exp_time)) { if (is_file($_filepath) && time() - filemtime($_filepath) >= $exp_time) { $unlink = true; } } else { $unlink = true; } } if ($unlink && is_file($_filepath) && @unlink($_filepath)) { $_count++; if (function_exists('opcache_invalidate') && (!function_exists('ini_get') || strlen(ini_get('opcache.restrict_api')) < 1) ) { opcache_invalidate($_filepath, true); } elseif (function_exists('apc_delete_file')) { apc_delete_file($_filepath); } } } } return $_count; } public function compileAllTemplates( $extension = '.tpl', $force_compile = false, $time_limit = 0, $max_errors = null ) { return $this->compileAll($extension, $force_compile, $time_limit, $max_errors); } public function compileAllConfig( $extension = '.conf', $force_compile = false, $time_limit = 0, $max_errors = null ) { return $this->compileAll($extension, $force_compile, $time_limit, $max_errors, true); } protected function compileAll( $extension, $force_compile, $time_limit, $max_errors, $isConfig = false ) { if (function_exists('set_time_limit')) { @set_time_limit($time_limit); } $_count = 0; $_error_count = 0; $sourceDir = $isConfig ? $this->getConfigDir() : $this->getTemplateDir(); foreach ($sourceDir as $_dir) { $_dir_1 = new RecursiveDirectoryIterator( $_dir, defined('FilesystemIterator::FOLLOW_SYMLINKS') ? FilesystemIterator::FOLLOW_SYMLINKS : 0 ); $_dir_2 = new RecursiveIteratorIterator($_dir_1); foreach ($_dir_2 as $_fileinfo) { $_file = $_fileinfo->getFilename(); if (substr(basename($_fileinfo->getPathname()), 0, 1) === '.' || strpos($_file, '.svn') !== false) { continue; } if (substr_compare($_file, $extension, -strlen($extension)) !== 0) { continue; } if ($_fileinfo->getPath() !== substr($_dir, 0, -1)) { $_file = substr($_fileinfo->getPath(), strlen($_dir)) . DIRECTORY_SEPARATOR . $_file; } echo "\n", $_dir, '---', $_file; flush(); $_start_time = microtime(true); $_smarty = clone $this; $_smarty->force_compile = $force_compile; try { $_tpl = $this->doCreateTemplate($_file); $_tpl->caching = self::CACHING_OFF; $_tpl->setSource( $isConfig ? \Smarty\Template\Config::load($_tpl) : \Smarty\Template\Source::load($_tpl) ); if ($_tpl->mustCompile()) { $_tpl->compileTemplateSource(); $_count++; echo ' compiled in  ', microtime(true) - $_start_time, ' seconds'; flush(); } else { echo ' is up to date'; flush(); } } catch (\Exception $e) { echo "\n        ------>Error: ", $e->getMessage(), "\n"; $_error_count++; } unset($_tpl); if ($max_errors !== null && $_error_count === $max_errors) { echo "\ntoo many errors\n"; exit(1); } } } echo "\n"; return $_count; } public function cacheModifiedCheck(Template\Cached $cached, Template $_template, $content) { $_isCached = $_template->isCached() && !$_template->getCompiled()->getNocacheCode(); $_last_modified_date = @substr($_SERVER['HTTP_IF_MODIFIED_SINCE'], 0, strpos($_SERVER['HTTP_IF_MODIFIED_SINCE'], 'GMT') + 3); if ($_isCached && $cached->timestamp <= strtotime($_last_modified_date)) { switch (PHP_SAPI) { case 'cgi': case 'cgi-fcgi': case 'fpm-fcgi': header('Status: 304 Not Modified'); break; case 'cli': if ( !empty($_SERVER['SMARTY_PHPUNIT_DISABLE_HEADERS']) ) { $_SERVER['SMARTY_PHPUNIT_HEADERS'][] = '304 Not Modified'; } break; default: if ( !empty($_SERVER['SMARTY_PHPUNIT_DISABLE_HEADERS']) ) { $_SERVER['SMARTY_PHPUNIT_HEADERS'][] = '304 Not Modified'; } else { header($_SERVER['SERVER_PROTOCOL'] . ' 304 Not Modified'); } break; } } else { switch (PHP_SAPI) { case 'cli': if ( !empty($_SERVER['SMARTY_PHPUNIT_DISABLE_HEADERS']) ) { $_SERVER['SMARTY_PHPUNIT_HEADERS'][] = 'Last-Modified: ' . gmdate('D, d M Y H:i:s', $cached->timestamp) . ' GMT'; } break; default: header('Last-Modified: ' . gmdate('D, d M Y H:i:s', $cached->timestamp) . ' GMT'); break; } echo $content; } } public function getModifierCallback(string $modifierName) { foreach ($this->getExtensions() as $extension) { if ($callback = $extension->getModifierCallback($modifierName)) { return [new CallbackWrapper($modifierName, $callback), 'handle']; } } return null; } public function getFunctionHandler(string $functionName): ?\Smarty\FunctionHandler\FunctionHandlerInterface { foreach ($this->getExtensions() as $extension) { if ($handler = $extension->getFunctionHandler($functionName)) { return $handler; } } return null; } public function getBlockHandler(string $blockTagName): ?\Smarty\BlockHandler\BlockHandlerInterface { foreach ($this->getExtensions() as $extension) { if ($handler = $extension->getBlockHandler($blockTagName)) { return $handler; } } return null; } public function getModifierCompiler(string $modifier): ?\Smarty\Compile\Modifier\ModifierCompilerInterface { foreach ($this->getExtensions() as $extension) { if ($handler = $extension->getModifierCompiler($modifier)) { return $handler; } } return null; } public function runPreFilters($source, Template $template) { foreach ($this->getExtensions() as $extension) { foreach ($extension->getPreFilters() as $filter) { $source = $filter->filter($source, $template); } } return $source; } public function runPostFilters($code, Template $template) { foreach ($this->getExtensions() as $extension) { foreach ($extension->getPostFilters() as $filter) { $code = $filter->filter($code, $template); } } return $code; } public function runOutputFilters($content, Template $template) { foreach ($this->getExtensions() as $extension) { foreach ($extension->getOutputFilters() as $filter) { $content = $filter->filter($content, $template); } } return $content; } public function writeFile($_filepath, $_contents) { $_error_reporting = error_reporting(); error_reporting($_error_reporting & ~E_NOTICE & ~E_WARNING); $_dirpath = dirname($_filepath); if ($_dirpath !== '.') { $i = 0; while (!is_dir($_dirpath)) { if (@mkdir($_dirpath, 0777, true)) { break; } clearstatcache(); if (++$i === 3) { error_reporting($_error_reporting); throw new Exception("unable to create directory {$_dirpath}"); } sleep(1); } } $_tmp_file = $_dirpath . DIRECTORY_SEPARATOR . str_replace(['.', ','], '_', uniqid('wrt', true)); if (!file_put_contents($_tmp_file, $_contents)) { error_reporting($_error_reporting); throw new Exception("unable to write file {$_tmp_file}"); } if (\Smarty\Smarty::$_IS_WINDOWS) { if (is_file($_filepath)) { @unlink($_filepath); } $success = @rename($_tmp_file, $_filepath); } else { $success = @rename($_tmp_file, $_filepath); if (!$success) { if (is_file($_filepath)) { @unlink($_filepath); } $success = @rename($_tmp_file, $_filepath); } } if (!$success) { error_reporting($_error_reporting); throw new Exception("unable to write file {$_filepath}"); } @chmod($_filepath, 0666 & ~umask()); error_reporting($_error_reporting); return true; } private $runtimes = []; public function getRuntime(string $type) { if (isset($this->runtimes[$type])) { return $this->runtimes[$type]; } switch ($type) { case 'Capture': return $this->runtimes[$type] = new CaptureRuntime(); case 'Foreach': return $this->runtimes[$type] = new ForeachRuntime(); case 'Inheritance': return $this->runtimes[$type] = new InheritanceRuntime(); case 'TplFunction': return $this->runtimes[$type] = new TplFunctionRuntime(); case 'DefaultPluginHandler': return $this->runtimes[$type] = new DefaultPluginHandlerRuntime( $this->getDefaultPluginHandlerFunc() ); } throw new \Smarty\Exception('Trying to load invalid runtime ' . $type); } public function hasRuntime(string $type): bool { try { $this->getRuntime($type); return true; } catch (\Smarty\Exception $e) { return false; } } public function getDefaultPluginHandlerFunc(): ?callable { return $this->default_plugin_handler_func; } public function loadFilter($type, $name) { if ($type == \Smarty\Smarty::FILTER_VARIABLE) { foreach ($this->getExtensions() as $extension) { if ($extension->getModifierCallback($name)) { trigger_error('Using Smarty::loadFilter() to load variable filters is deprecated and will ' . 'be removed in a future release. Use Smarty::addDefaultModifiers() to add a modifier.', E_USER_DEPRECATED); $this->addDefaultModifiers([$name]); return true; } } } trigger_error('Using Smarty::loadFilter() to load filters is deprecated and will be ' . 'removed in a future release. Use Smarty::addExtension() to add an extension or Smarty::registerFilter to ' . 'quickly register a filter using a callback function.', E_USER_DEPRECATED); if ($type == \Smarty\Smarty::FILTER_OUTPUT && $name == 'trimwhitespace') { $this->BCPluginsAdapter->addOutputFilter(new TrimWhitespace()); return true; } $_plugin = "smarty_{$type}filter_{$name}"; if (!is_callable($_plugin) && class_exists($_plugin, false)) { $_plugin = [$_plugin, 'execute']; } if (is_callable($_plugin)) { $this->registerFilter($type, $_plugin, $name); return true; } throw new Exception("{$type}filter '{$name}' not found or callable"); } public function unloadFilter($type, $name) { trigger_error('Using Smarty::unloadFilter() to unload filters is deprecated and will be ' . 'removed in a future release. Use Smarty::addExtension() to add an extension or Smarty::(un)registerFilter to ' . 'quickly (un)register a filter using a callback function.', E_USER_DEPRECATED); return $this->unregisterFilter($type, $name); } private $_caching_type = 'file'; public function setCachingType($type) { trigger_error('Using Smarty::setCachingType() is deprecated and will be ' . 'removed in a future release. Use Smarty::setCacheResource() instead.', E_USER_DEPRECATED); $this->_caching_type = $type; $this->activateBCCacheResource(); } public function getCachingType(): string { trigger_error('Using Smarty::getCachingType() is deprecated and will be ' . 'removed in a future release.', E_USER_DEPRECATED); return $this->_caching_type; } public function registerCacheResource($name, \Smarty\Cacheresource\Base $resource_handler) { trigger_error('Using Smarty::registerCacheResource() is deprecated and will be ' . 'removed in a future release. Use Smarty::setCacheResource() instead.', E_USER_DEPRECATED); $this->registered_cache_resources[$name] = $resource_handler; $this->activateBCCacheResource(); return $this; } public function unregisterCacheResource($name) { trigger_error('Using Smarty::unregisterCacheResource() is deprecated and will be ' . 'removed in a future release.', E_USER_DEPRECATED); if (isset($this->registered_cache_resources[$name])) { unset($this->registered_cache_resources[$name]); } return $this; } private function activateBCCacheResource() { if ($this->_caching_type == 'file') { $this->setCacheResource(new File()); } if (isset($this->registered_cache_resources[$this->_caching_type])) { $this->setCacheResource($this->registered_cache_resources[$this->_caching_type]); } } public function registerFilter($type, $callback, $name = null) { $name = $name ?? $this->_getFilterName($callback); if (!is_callable($callback)) { throw new Exception("{$type}filter '{$name}' not callable"); } switch ($type) { case 'variable': $this->registerPlugin(self::PLUGIN_MODIFIER, $name, $callback); trigger_error('Using Smarty::registerFilter() to register variable filters is deprecated and ' . 'will be removed in a future release. Use Smarty::addDefaultModifiers() to add a modifier.', E_USER_DEPRECATED); $this->addDefaultModifiers([$name]); break; case 'output': $this->BCPluginsAdapter->addCallableAsOutputFilter($callback, $name); break; case 'pre': $this->BCPluginsAdapter->addCallableAsPreFilter($callback, $name); break; case 'post': $this->BCPluginsAdapter->addCallableAsPostFilter($callback, $name); break; default: throw new Exception("Illegal filter type '{$type}'"); } return $this; } private function _getFilterName($callable) { if (is_array($callable)) { $_class_name = is_object($callable[0]) ? get_class($callable[0]) : $callable[0]; return $_class_name . '_' . $callable[1]; } elseif (is_string($callable)) { return $callable; } return null; } public function unregisterFilter($type, $name) { if (!is_string($name)) { $name = $this->_getFilterName($name); } if ($name) { switch ($type) { case 'output': $this->BCPluginsAdapter->removeOutputFilter($name); break; case 'pre': $this->BCPluginsAdapter->removePreFilter($name); break; case 'post': $this->BCPluginsAdapter->removePostFilter($name); break; default: throw new Exception("Illegal filter type '{$type}'"); } } return $this; } public function addDefaultModifiers($modifiers) { if (is_array($modifiers)) { $this->default_modifiers = array_merge($this->default_modifiers, $modifiers); } else { $this->default_modifiers[] = $modifiers; } return $this; } public function getDefaultModifiers() { return $this->default_modifiers; } public function setDefaultModifiers($modifiers) { $this->default_modifiers = (array)$modifiers; return $this; } public function getCacheResource(): Cacheresource\Base { return $this->cacheResource; } public function setCacheResource(Cacheresource\Base $cacheResource): void { $this->cacheResource = $cacheResource; } public function fetch($template = null, $cache_id = null, $compile_id = null) { return $this->returnOrCreateTemplate($template, $cache_id, $compile_id)->fetch(); } public function display($template = null, $cache_id = null, $compile_id = null) { $this->returnOrCreateTemplate($template, $cache_id, $compile_id)->display(); } public function doCreateTemplate( $resource_name, $cache_id = null, $compile_id = null, $parent = null, $caching = null, $cache_lifetime = null, bool $isConfig = false, array $data = []): Template { if (!$this->_templateDirNormalized) { $this->_normalizeTemplateConfig(false); } $_templateId = $this->generateUniqueTemplateId($resource_name, $cache_id, $compile_id, $caching); if (!isset($this->templates[$_templateId])) { $newTemplate = new Template($resource_name, $this, $parent ?: $this, $cache_id, $compile_id, $caching, $isConfig); $newTemplate->templateId = $_templateId; $this->templates[$_templateId] = $newTemplate; } $tpl = clone $this->templates[$_templateId]; $tpl->setParent($parent ?: $this); if ($cache_lifetime) { $tpl->setCacheLifetime($cache_lifetime); } foreach ($data as $_key => $_val) { $tpl->assign($_key, $_val); } $tpl->tplFunctions = array_merge($parent->tplFunctions ?? [], $tpl->tplFunctions ?? []); if (!$this->debugging && $this->debugging_ctrl === 'URL') { $tpl->getSmarty()->getDebug()->debugUrl($tpl->getSmarty()); } return $tpl; } public function isCached($template = null, $cache_id = null, $compile_id = null) { return $this->returnOrCreateTemplate($template, $cache_id, $compile_id)->isCached(); } private function returnOrCreateTemplate($template, $cache_id = null, $compile_id = null) { if (!($template instanceof Template)) { $template = $this->createTemplate($template, $cache_id, $compile_id, $this); $template->caching = $this->caching; } return $template; } public function setCacheModifiedCheck($cache_modified_check): void { $this->cache_modified_check = (bool) $cache_modified_check; } } 