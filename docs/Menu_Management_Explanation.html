<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestión de Menús en Aplicaciones CLI (POO PHP)</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 900px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #0056b3; }
        pre { background: #e9e9e9; padding: 15px; border-radius: 5px; overflow-x: auto; }
        code { font-family: "Courier New", Courier, monospace; background: #e9e9e9; padding: 2px 4px; border-radius: 3px; }
        .method-section { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
        .method-section:last-child { border-bottom: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gestión de Menús en Aplicaciones CLI (POO PHP)</h1>
        <p>En el desarrollo de aplicaciones de línea de comandos (CLI) con PHP y Programación Orientada a Objetos (POO), la gestión de menús es un componente fundamental para la interacción con el usuario. Este documento explora dos enfoques para manejar las opciones de un menú, destacando sus ventajas y desventajas.</p>

        <h2>1. Gestión de Menú con Sentencias <code>if</code> (Enfoque Básico)</h2>
        <p>Este enfoque es intuitivo para principiantes y se basa en capturar la descripción de la opción seleccionada por el usuario y luego usar sentencias condicionales (<code>if</code>, <code>else if</code>) para determinar qué acción ejecutar.</p>

        <h3>Concepto</h3>
        <p>Después de que el usuario selecciona una opción, se obtiene la descripción textual asociada a esa opción (por ejemplo, "Añadir Repuesto"). Luego, se compara esta descripción con una serie de condiciones predefinidas para ejecutar el código correspondiente.</p>

        <h3>Ejemplo (dentro de <code>ejecutarOpcion</code> o similar)</h3>
        <pre><code>public function ejecutarOpcion($seleccion) {
    if (array_key_exists($seleccion, $this->opciones)) {
        $descripcion = $this->opciones[$seleccion]; // Capturamos la descripción

        echo "Has seleccionado: " . $descripcion . "
";

        if ($descripcion === 'Añadir Repuesto') {
            // Lógica para añadir un repuesto
            echo "Ejecutando la función para añadir un repuesto...
";
        } else if ($descripcion === 'Listar Repuestos') {
            // Lógica para listar repuestos
            echo "Ejecutando la función para listar repuestos...
";
        } else if ($descripcion === 'Salir') {
            return false; // Indica que el menú debe detenerse
        } else {
            echo "Acción no implementada para: " . $descripcion . "
";
        }
    } else {
        echo "Opción inválida. Por favor, intente de nuevo.
";
    }
    return true; // Indica que el menú debe continuar
}</code></pre>

        <h3>Ventajas</h3>
        <ul>
            <li><strong>Simplicidad:</strong> Fácil de entender e implementar para menús pequeños y estáticos.</li>
            <li><strong>Claridad Directa:</strong> La lógica es muy explícita, ya que cada <code>if</code> corresponde directamente a una descripción de opción.</li>
        </ul>

        <h3>Desventajas</h3>
        <ul>
            <li><strong>Ineficiencia para Menús Dinámicos:</strong> Si las opciones del menú cambian frecuentemente o se generan dinámicamente, mantener una larga cadena de <code>if/else if</code> se vuelve tedioso y propenso a errores.</li>
            <li><strong>Acoplamiento Fuerte:</strong> El código de la lógica de ejecución está fuertemente acoplado a las descripciones textuales de las opciones. Un cambio en la descripción requiere un cambio en la lógica condicional.</li>
            <li><strong>Escalabilidad Limitada:</strong> A medida que el número de opciones crece, el método <code>ejecutarOpcion</code> se vuelve muy largo y difícil de manejar.</li>
        </ul>

        <h2>2. Gestión de Menú Dinámica con el Array de Opciones (Enfoque Recomendado)</h2>
        <p>Este enfoque es más robusto y flexible, ideal para menús que pueden crecer o cambiar. Se basa en asociar cada opción no solo con una descripción, sino también con una acción (por ejemplo, una función o un método) que se ejecutará.</p>

        <h3>Concepto</h3>
        <p>En lugar de solo almacenar descripciones, el array <code>$opciones</code> puede almacenar pares de clave-valor donde la clave es el número de la opción y el valor es un array asociativo que contiene tanto la descripción como la acción a ejecutar (por ejemplo, un "callback" o una referencia a una función/método).</p>

        <h3>Modificación de la Clase <code>Menu</code> (Ejemplo Conceptual)</h3>
        <p>Para implementar esto, la propiedad <code>$opciones</code> y el método <code>ejecutarOpcion</code> necesitarían ser modificados. Aquí un ejemplo conceptual de cómo se podría estructurar el array de opciones y cómo se ejecutaría la acción.</p>

        <h4>Definición de Opciones (en <code>Main.php</code> o similar)</h4>
        <pre><code>// Definir las opciones del menú principal con acciones asociadas
$opcionesMenuPrincipal = [
    1 => ['descripcion' => 'Añadir Repuesto', 'accion' => function() {
        echo "Ejecutando la función para añadir un repuesto (desde un callback)...
";
        // Aquí iría la llamada a la función o método real para añadir repuestos
    }],
    2 => ['descripcion' => 'Listar Repuestos', 'accion' => function() {
        echo "Ejecutando la función para listar repuestos (desde un callback)...
";
        // Aquí iría la llamada a la función o método real para listar repuestos
    }],
    3 => ['descripcion' => 'Salir', 'accion' => function() {
        echo "Saliendo de la aplicación...
";
    }]
];

// Crear una instancia del menú (el constructor necesitaría adaptarse)
// $menuPrincipal = new Menu("Menú Principal de Inventario", $opcionesMenuPrincipal);
</code></pre>

        <h4>Método <code>ejecutarOpcion</code> Modificado (Ejemplo Conceptual)</h4>
        <pre><code>public function ejecutarOpcion($seleccion) {
    if (array_key_exists($seleccion, $this->opciones)) {
        $opcionSeleccionada = $this->opciones[$seleccion];
        $descripcion = $opcionSeleccionada['descripcion'];
        $accion = $opcionSeleccionada['accion']; // Obtenemos la acción asociada

        echo "Has seleccionado: " . $descripcion . "\n";

        // Ejecutamos la acción (si es un callable)
        if (is_callable($accion)) {
            call_user_func($accion); // Ejecuta la función anónima o callback
        } else {
            echo "La acción para '" . $descripcion . "' no es ejecutable.\n";
        }

        if ($descripcion === 'Salir') {
            return false; // Indica que el menú debe detenerse
        }
    } else {
        echo "Opción inválida. Por favor, intente de nuevo.\n";
    }
    return true; // Indica que el menú debe continuar
}</code></pre>

        <h3>Ventajas</h3>
        <ul>
            <li><strong>Dinamismo y Flexibilidad:</strong> Las opciones y sus acciones pueden ser definidas y modificadas fácilmente sin alterar la lógica central del menú.</li>
            <li><strong>Bajo Acoplamiento:</strong> La clase <code>Menu</code> no necesita saber los detalles de cada acción; simplemente las ejecuta. Esto promueve un diseño más modular.</li>
            <li><strong>Escalabilidad:</strong> Añadir nuevas opciones es tan simple como agregar un nuevo elemento al array <code>$opciones</code>.</li>
            <li><strong>Reutilización:</strong> Las funciones o métodos que realizan las acciones pueden ser reutilizados en otras partes de la aplicación.</li>
        </ul>

        <h3>Desventajas</h3>
        <ul>
            <li><strong>Curva de Aprendizaje Inicial:</strong> Puede ser un poco más complejo de entender al principio, especialmente el concepto de "callbacks" o funciones anónimas.</li>
            <li><strong>Mayor Complejidad en la Definición:</strong> La definición del array de opciones es más detallada.</li>
        </ul>

        <h3>Uso de Métodos de Objeto como Acciones</h3>
        <p>Una extensión natural del enfoque dinámico es asociar las opciones del menú con métodos de objetos específicos. Esto es particularmente útil en POO, ya que permite que cada acción esté encapsulada dentro de la clase o clases responsables de esa funcionalidad.</p>

        <h4>Concepto</h4>
        <p>En lugar de una función anónima, la 'acción' en el array <code>$opciones</code> puede ser un array que especifique un objeto y el nombre de uno de sus métodos (<code>[$objeto, 'nombreMetodo']</code>). PHP permite llamar a estos "callables" de la misma manera que a las funciones anónimas.</p>

        <h4>Ejemplo: Clase <code>ManejadorInventario</code></h4>
        <p>Imaginemos una clase <code>ManejadorInventario</code> que contiene la lógica para añadir y listar repuestos:</p>
        <pre><code>class ManejadorInventario {
    public function añadirRepuesto() {
        echo "Lógica para añadir un nuevo repuesto (desde ManejadorInventario::añadirRepuesto)...\n";
    }

    public function listarRepuestos() {
        echo "Lógica para listar todos los repuestos (desde ManejadorInventario::listarRepuestos)...\n";
    }

    public function salirAplicacion() {
        echo "Cerrando la aplicación de inventario (desde ManejadorInventario::salirAplicacion)...\n";
    }
}</code></pre>

        <h4>Definición de Opciones con Métodos de Objeto</h4>
        <pre><code>// Crear una instancia del manejador de inventario
$manejador = new ManejadorInventario();

// Definir las opciones del menú principal, asociando métodos de objeto
$opcionesMenuPrincipal = [
    1 => ['descripcion' => 'Añadir Repuesto', 'accion' => [$manejador, 'añadirRepuesto']],
    2 => ['descripcion' => 'Listar Repuestos', 'accion' => [$manejador, 'listarRepuestos']],
    3 => ['descripcion' => 'Salir', 'accion' => [$manejador, 'salirAplicacion']]
];

// El constructor del menú necesitaría recibir estas opciones
// $menuPrincipal = new Menu("Menú Principal de Inventario", $opcionesMenuPrincipal);
</code></pre>

        <h4>Método <code>ejecutarOpcion</code> (sin cambios, ya soporta callables)</h4>
        <p>La belleza de este enfoque es que el método <code>ejecutarOpcion</code> que ya hemos visto no necesita cambios, ya que <code>is_callable()</code> y <code>call_user_func()</code> de PHP son lo suficientemente flexibles como para manejar tanto funciones anónimas como arrays <code>[$objeto, 'nombreMetodo']</code>.</p>
        <pre><code>public function ejecutarOpcion($seleccion) {
    if (array_key_exists($seleccion, $this->opciones)) {
        $opcionSeleccionada = $this->opciones[$seleccion];
        $descripcion = $opcionSeleccionada['descripcion'];
        $accion = $opcionSeleccionada['accion'];

        echo "Has seleccionado: " . $descripcion . "\n";

        if (is_callable($accion)) {
            call_user_func($accion); // Esto ejecutará el método del objeto
        } else {
            echo "La acción para '" . $descripcion . "' no es ejecutable.\n";
        }

        if ($descripcion === 'Salir') {
            return false;
        }
    } else {
        echo "Opción inválida. Por favor, intente de nuevo.\n";
    }
    return true;
}</code></pre>

        <h3>Ventajas Adicionales de Usar Métodos de Objeto</h3>
        <ul>
            <li><strong>Encapsulamiento:</strong> La lógica de cada acción está contenida dentro de su propia clase, mejorando la organización del código.</li>
            <li><strong>Cohesión:</strong> Las clases se vuelven más cohesivas, ya que agrupan funcionalidades relacionadas.</li>
            <li><strong>Reutilización y Mantenibilidad:</strong> Facilita la reutilización de la lógica de negocio y simplifica el mantenimiento al tener responsabilidades claras.</li>
        </ul>

        <h2>Conclusión</h2>
        <p>Mientras que el uso de sentencias <code>if</code> para gestionar menús es un buen punto de partida para comprender la lógica básica, el enfoque dinámico utilizando un array de opciones con acciones asociadas (callbacks) es significativamente más potente y escalable para aplicaciones POO en PHP. Este último método promueve un código más limpio, modular y fácil de mantener a largo plazo.</p>
    </div>
</body>
</html>