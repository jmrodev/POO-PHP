<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visión General del Proyecto TP-Inventario (Estado Actual)</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 900px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3, h4 { color: #0056b3; }
        pre { background: #e9e9e9; padding: 15px; border-radius: 5px; overflow-x: auto; margin-bottom: 1em; }
        code { font-family: "Courier New", Courier, monospace; background: #e9e9e9; padding: 2px 4px; border-radius: 3px; }
        ul { list-style-type: disc; margin-left: 20px; }
        li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Visión General del Proyecto TP-Inventario (Estado Actual)</h1>

        <p>Este documento proporciona una visión general de la arquitectura y los componentes clave del proyecto "TP-Inventario" en su estado actual, destacando el propósito, los métodos principales y las particularidades de cada elemento.</p>

        <h2>Componentes Clave del Proyecto</h2>

        <h3>1. Clase <code>Repuesto</code> (y sus subclases)</h3>
        <ul>
            <li><strong>Propósito:</strong> Sirve como la clase base abstracta para todos los tipos de repuestos en el inventario. Encapsula las propiedades comunes a cualquier repuesto (ID, nombre, descripción, precio, cantidad, categoría, marca, modelo).</li>
            <li><strong>Subclases:</strong>
                <ul>
                    <li><code>RepuestoMoto</code>: Hereda de <code>Repuesto</code>, con categoría fija "Moto".</li>
                    <li><code>RepuestoCamion</code>: Hereda de <code>Repuesto</code>, con categoría fija "Camion".</li>
                    <li><code>RepuestoCamioneta</code>: Hereda de <code>Repuesto</code>, con categoría fija "Camioneta" y añade una propiedad específica: <code>traccion</code>.</li>
                </ul>
            </li>
            <li><strong>Particularidades:</strong>
                <ul>
                    <li>Utiliza herencia para modelar diferentes tipos de repuestos, promoviendo la reutilización de código y la especialización.</li>
                    <li>Cada subclase define su categoría de forma implícita en su constructor.</li>
                    <li>Incluye métodos "getter" y "setter" para todas sus propiedades, siguiendo el principio de encapsulamiento.</li>
                </ul>
            </li>
        </ul>

        <h3>2. Clase <code>RepuestoFactory</code></h3>
        <ul>
            <li><strong>Propósito:</strong> Implementa el patrón Factory Method para la creación de objetos <code>Repuesto</code>. Su función es centralizar la lógica de instanciación de los diferentes tipos de repuestos.</li>
            <li><strong>Métodos Principales:</strong>
                <ul>
                    <li><code>public static function crearRepuesto(string $tipo, array $datos): ?Repuesto</code>: Recibe el tipo de repuesto deseado (ej. "Moto", "Camioneta") y un array de datos, y devuelve una instancia del repuesto correspondiente.</li>
                </ul>
            </li>
            <li><strong>Particularidades:</strong>
                <ul>
                    <li>Desacopla el código cliente de la lógica de creación de objetos, haciendo que sea más fácil añadir nuevos tipos de repuestos en el futuro sin modificar el código que los utiliza.</li>
                    <li>Maneja la asignación de propiedades comunes y específicas (como la tracción para camionetas) durante la creación.</li>
                </ul>
            </li>
        </ul>

        <h3>3. Clase <code>InMemoryDatabase</code></h3>
        <ul>
            <li><strong>Propósito:</strong> Simula una base de datos en memoria para el almacenamiento persistente (durante la ejecución de la aplicación) de los objetos <code>Repuesto</code>.</li>
            <li><strong>Métodos Principales:</strong>
                <ul>
                    <li><code>public static function getInstance(): InMemoryDatabase</code>: Implementa el patrón Singleton para asegurar que solo exista una instancia de la base de datos en toda la aplicación.</li>
                    <li><code>public function addRepuesto($repuesto)</code>: Añade un repuesto al almacenamiento.</li>
                    <li><code>public function getRepuestoById($id)</code>: Recupera un repuesto por su ID.</li>
                    <li><code>public function getAllRepuestos()</code>: Devuelve todos los repuestos almacenados.</li>
                    <li><code>public function removeRepuesto($id): bool</code>: Elimina un repuesto por su ID.</li>
                </ul>
            </li>
            <li><strong>Particularidades:</strong>
                <ul>
                    <li>Utiliza un array estático (<code>self::$repuestos</code>) para almacenar los objetos, simulando una tabla de base de datos.</li>
                    <li>Asigna automáticamente un ID único a cada repuesto añadido.</li>
                    <li>Implementa el patrón Singleton para proporcionar un punto de acceso global y controlado a la base de datos.</li>
                </ul>
            </li>
        </ul>

        <h3>4. Clase <code>InventoryManager</code></h3>
        <ul>
            <li><strong>Propósito:</strong> Actúa como el "cerebro" de la aplicación, encapsulando toda la lógica de negocio del inventario. Es el punto de conexión entre la interfaz de usuario (menú) y los componentes de datos (base de datos, fábrica de repuestos).</li>
            <li><strong>Métodos Principales:</strong>
                <ul>
                    <li><code>public function __construct(InMemoryDatabase $db, RepuestoFactory $repuestoFactory)</code>: Recibe las dependencias necesarias (base de datos y fábrica) a través de inyección de dependencias.</li>
                    <li><code>public function addSparePart()</code>: Guía al usuario para introducir los datos de un nuevo repuesto y lo añade a la base de datos.</li>
                    <li><code>public function listSpareParts()</code>: Muestra un listado formateado de todos los repuestos.</li>
                    <li><code>public function editSparePart()</code>: Permite al usuario buscar y modificar los detalles de un repuesto existente.</li>
                    <li><code>public function deleteSparePart()</code>: Permite al usuario eliminar un repuesto por su ID.</li>
                    <li><code>public function exitApplication()</code>: Maneja la acción de salida de la aplicación.</li>
                </ul>
            </li>
            <li><strong>Particularidades:</strong>
                <ul>
                    <li>Centraliza la lógica de interacción con el usuario y la manipulación de datos, manteniendo <code>Main.php</code> limpio.</li>
                    <li>Promueve la separación de responsabilidades (SRP): <code>InventoryManager</code> se encarga de la lógica de negocio, <code>Menu</code> de la interfaz, <code>InMemoryDatabase</code> del almacenamiento.</li>
                </ul>
            </li>
        </ul>

        <h3>5. Clase <code>Menu</code></h3>
        <ul>
            <li><strong>Propósito:</strong> Proporciona una interfaz de usuario interactiva basada en texto para aplicaciones de línea de comandos (CLI).</li>
            <li><strong>Métodos Principales:</strong>
                <ul>
                    <li><code>public function __construct($titulo, array $opciones)</code>: Inicializa el menú con un título y un array de opciones.</li>
                    <li><code>public function mostrar()</code>: Imprime el menú en la consola.</li>
                    <li><code>public function obtenerSeleccion()</code>: Captura la entrada del usuario.</li>
                    <li><code>public function ejecutarOpcion($seleccion)</code>: Valida la selección del usuario y ejecuta la acción asociada (un "callable").</li>
                    <li><code>public function iniciar()</code>: Ejecuta el ciclo principal del menú (mostrar, obtener selección, ejecutar) hasta que el usuario decide salir.</li>
                    <li><code>public static function createMainMenu(InventoryManager $manager): self</code>: **Método estático de fábrica** que crea y configura el menú principal específico para la aplicación de inventario, utilizando los métodos de <code>InventoryManager</code> como acciones.</li>
                </ul>
            </li>
            <li><strong>Particularidades:</strong>
                <ul>
                    <li>Diseño genérico y reutilizable para cualquier menú CLI.</li>
                    <li>Utiliza "callables" (funciones anónimas o arrays <code>[$objeto, 'metodo']</code>) para asociar acciones a las opciones del menú, lo que proporciona gran flexibilidad.</li>
                    <li>El método de fábrica <code>createMainMenu</code> centraliza la configuración del menú principal, desacoplando su definición de <code>Main.php</code>.</li>
                </ul>
            </li>
        </ul>

        <h3>6. Archivo <code>Main.php</code></h3>
        <ul>
            <li><strong>Propósito:</strong> Es el punto de entrada principal de la aplicación. Su rol es orquestar la inicialización de los componentes y el inicio del flujo de la aplicación.</li>
            <li><strong>Particularidades:</strong>
                <ul>
                    <li>Incluye todos los archivos de clases necesarios.</li>
                    <li>Inicializa las dependencias clave: <code>InMemoryDatabase</code> (usando su Singleton) y <code>RepuestoFactory</code>.</li>
                    <li>Crea una instancia de <code>InventoryManager</code>, inyectándole las dependencias.</li>
                    <li>Utiliza el método estático de fábrica <code>Menu::createMainMenu()</code> para construir el menú principal, pasándole la instancia de <code>InventoryManager</code>.</li>
                    <li>Inicia el ciclo de interacción del menú llamando a <code>$menuPrincipal->iniciar()</code>.</li>
                    <li>Su lógica es mínima y se enfoca en la configuración y el arranque, delegando las responsabilidades a las clases correspondientes.</li>
                </ul>
            </li>
        </ul>

        <h2>Principios de POO y Patrones de Diseño Aplicados</h2>
        <ul>
            <li><strong>Encapsulamiento:</strong> Todas las clases utilizan propiedades privadas y métodos públicos (getters/setters) para controlar el acceso a sus datos internos.</li>
            <li><strong>Herencia:</strong> Demostrada por la jerarquía de clases <code>Repuesto</code> y sus subclases, permitiendo la reutilización de código y la especialización.</li>
            <li><strong>Polimorfismo:</strong> El sistema puede manejar diferentes tipos de objetos <code>Repuesto</code> de manera uniforme a través de la clase base <code>Repuesto</code>, por ejemplo, al listarlos o almacenarlos.</li>
            <li><strong>Abstracción:</strong> Clases como <code>Menu</code> y <code>InventoryManager</code> abstraen la complejidad de la interacción con el usuario y la lógica de negocio, respectivamente, proporcionando interfaces sencillas.</li>
            <li><strong>Patrón Singleton:</strong> Implementado en <code>InMemoryDatabase</code> para asegurar una única instancia global de la base de datos.</li>
            <li><strong>Patrón Factory Method:</strong> Implementado en <code>RepuestoFactory</code> para la creación desacoplada de objetos <code>Repuesto</code>.</li>
            <li><strong>Inyección de Dependencias:</strong> Utilizado en el constructor de <code>InventoryManager</code> y en el método de fábrica <code>Menu::createMainMenu</code> para pasar las dependencias necesarias, mejorando la flexibilidad y testabilidad.</li>
            <li><strong>Separación de Responsabilidades (SRP):</strong> Cada clase tiene una única razón para cambiar, lo que hace el código más fácil de entender y mantener.</li>
        </ul>
    </div>
</body>
</html>